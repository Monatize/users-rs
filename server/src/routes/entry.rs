// Rust Libs
use std::env;
// Rust Libs


// 3rd Party Libs
use axum::{response::Json, Extension, http::StatusCode, response::IntoResponse}; // * Run web server, bring in Prisma connection from main.rs, return status codes and JSON
use jsonwebtoken::{encode, Header, EncodingKey}; // * Sign auth tokens
use serde_json::json; // * Return JSON values from the API
use crate::prisma::{self, users}; // * Technically a local file but generated by Prisma-Client-Rust, anyways, query users and use prisma functions
use prisma_client_rust::chrono::{Utc, DateTime, Duration}; // * Generate DateTime timestamps and Unix timestamps 
use dotenv::dotenv; // * Call in vars from .env
// 3rd Party Libs

// Local Imports
use crate::utils; // * Generate ETH Signed Message/Get Public Key from signature
use crate::types::entry::{error::{EntryError, Data}, success::{EntrySuccess, SuccessData}, user::User}; // * Success Model for API
use crate::types::shared::{jwt::Claims, status::StatusCodes};
// Local Imports

// Types
type Database = Extension<std::sync::Arc<prisma::PrismaClient>>; // * Import prisma connection from main.rs
// Types

pub async fn entry(
    Json(payload): Json<User>,
    ctx: Database
) -> impl IntoResponse {   
    let [address, signature, nonce] = [payload.address, payload.signature, payload.nonce];
    dotenv().ok();
    let pubkey = utils::get_pubkey::get_pubkey(address.clone(), nonce.clone(), signature.clone());

    match pubkey {
        // * If the get_pubkey() request succeeded, go on
        Ok(pubkey) => {
            if &pubkey.to_lowercase() == &address.to_lowercase() {
                let current_utc_time = Utc::now();
                let upsert = ctx.users().upsert(users::address::equals(String::from(&address)), users::create(
                    String::from(&address),
                    String::from(&signature),
                    String::from(&nonce),
                    DateTime::from(current_utc_time),
                    vec![]
                ), vec![
                    users::signature::set(String::from(&signature)),
                    users::nonce::set(String::from(&nonce)),
                    users::updated_on::set(Some(DateTime::from(current_utc_time)))
                ]).exec().await;

                match upsert {
                    Ok(data) => {
                        // * Sign JWT
                        println!("{}", (Utc::now() + Duration::days(1)).timestamp() as usize);
                        let claims = Claims {
                            address: data.address,
                            signature: data.signature,
                            nonce: data.nonce,
                            exp: (Utc::now() + Duration::days(1)).timestamp() as usize
                        };

                        let signing_key = env::var("JWT_PRIVATE_KEY").unwrap();
                        let token = encode(&Header::default(), &claims, &EncodingKey::from_secret(signing_key.as_ref()));
                        match token {
                            Ok(token) => {
                                let success_data = SuccessData {
                                    token
                                };

                                let success_struct = EntrySuccess {
                                    status: StatusCodes::Success,
                                    data: success_data,
                                    message: String::from("Success!")
                                };

                                return (StatusCode::OK, Json(json!(success_struct)))

                            }
                            Err(e) => {
                                let error_data = Data {
                                    token: None
                                };

                                let error_struct = EntryError {
                                    status: StatusCodes::ServerError,
                                    data: error_data,
                                    message: String::from("Uh oh! Seems like we had a backend issue, please try again or contact us.")
                                };

                                println!("JWT could not be encoded");
                                println!("Address: {}", address);
                                println!("Nonce: {}", nonce);
                                println!("Signature: {}", signature);
                                println!("Encoding Error: {:?}", e);
                                return (StatusCode::INTERNAL_SERVER_ERROR, Json(json!(error_struct)))
                            }
                        }
                    }
                    Err(e) => {
                        let error_data = Data {
                            token: None
                        };

                        let error_struct = EntryError {
                            status: StatusCodes::ServerError,
                            data: error_data,
                            message: String::from("Uh oh! Seems like we had a backend issue, please try again or contact us.")
                        };
                        
                        println!("Data could not be upserted");
                        println!("Address: {}", address);
                        println!("Nonce: {}", nonce);
                        println!("Signature: {}", signature);
                        println!("Upsert Error: {:?}", e);
                        return (StatusCode::INTERNAL_SERVER_ERROR, Json(json!(error_struct)))
                    }
                }
            }
            else {
                let error_data = Data {
                    token: None
                };

                let error_struct = EntryError {
                    status: StatusCodes::Unauthorized,
                    data: error_data,
                    message: String::from("Recovered pubkey did not match provided address")
                };
                println!("Recovered pubkey did not match provided address");
                println!("Pubkey: {}", pubkey.to_lowercase());
                println!("Lowercase Address: {}", address.to_lowercase());
                println!("Address: {}", address);
                println!("Nonce: {}", nonce);
                println!("Signature: {}", signature);
                return (StatusCode::UNAUTHORIZED, Json(json!(error_struct)))
            }
        }
        
        // * If the get_pubkey() request failed, return an Error
        Err(e) => {
            let error_data = Data {
                token: None
            };
    
            let error_struct = EntryError {
                status: StatusCodes::ServerError,
                data: error_data,
                message: String::from("Couldn't retrieve pubkey")
            };

            println!("Couldn't retrieve pubkey!");
            println!("Address: {}", address.to_lowercase());
            println!("Nonce: {}", nonce);
            println!("Signature: {}", signature);
            println!("Error: {}", e);
            return (StatusCode::BAD_REQUEST, Json(json!(error_struct)))
        }
    }

}

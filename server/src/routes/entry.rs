// Rust Libs
// Rust Libs

use axum::http::StatusCode;
use axum::response::IntoResponse;
// 3rd Party Libs
use axum::{response::Json, Extension}; // * Run web server and bring in Prisma connection from main.rs
use serde_json::json; // * Return JSON values from the API
use serde::Deserialize;
use crate::prisma; // * Technically a local file but generated by Prisma-Client-Rust
// 3rd Party Libs

// Local Imports
use crate::utils; // * Generate ETH Signed Message/Get Public Key from signature
use crate::types::entry::{error::{EntryError, Data}, status::StatusCodes}; // * Success Model for API
// Local Imports

// Types
type Database = Extension<std::sync::Arc<prisma::PrismaClient>>;
// Types






#[derive(Deserialize)]
pub struct User {
    address: String,
    signature: String,
    nonce: String,
}

pub async fn entry(
    Json(payload): Json<User>,
    _ctx: Database
) -> impl IntoResponse {   
    let [address, signature, nonce] = [payload.address, payload.signature, payload.nonce];

    let pubkey = utils::get_pubkey::get_pubkey(address.clone(), nonce.clone(), signature.clone());

    match pubkey {
        // * If the get_pubkey() request succeeded, go on
        Ok(pubkey) => {
            if &pubkey == &address {
                return (StatusCode::OK, Json(json!({"test": "test"})))
            }
            else {
                let error_data = Data {
                    token: None
                };

                let error_struct = EntryError {
                    status: StatusCodes::Unauthorized,
                    data: error_data,
                    message: String::from("")
                };

                return (StatusCode::UNAUTHORIZED, Json(json!(error_struct)))
            }
        }
        
        // * If the get_pubkey() request failed, return an Error
        Err(e) => {
            println!("{}", e);
            let error_data = Data {
                token: None
            };
    
            let error_struct = EntryError {
                status: StatusCodes::ServerError,
                data: error_data,
                message: String::from("")
            };

            return (StatusCode::BAD_REQUEST, Json(json!(error_struct)))
        }
    }

}

// Rust Libs
// Rust Libs

use axum::http::StatusCode;
use axum::response::IntoResponse;
// 3rd Party Libs
use axum::{response::Json, Extension}; // * Run web server and bring in Prisma connection from main.rs
use serde_json::json; // * Return JSON values from the API
use serde::{Serialize, Deserialize};
use crate::prisma; // * Technically a local file but generated by Prisma-Client-Rust
use crate::prisma::users;
use prisma_client_rust::chrono::{Utc, DateTime};
// 3rd Party Libs

// Local Imports
use crate::utils; // * Generate ETH Signed Message/Get Public Key from signature
use crate::types::entry::{error::{EntryError, Data}, status::StatusCodes}; // * Success Model for API
// Local Imports

// Types
type Database = Extension<std::sync::Arc<prisma::PrismaClient>>;
// Types






#[derive(Deserialize)]
pub struct User {
    address: String,
    signature: String,
    nonce: String,
}

pub async fn entry(
    Json(payload): Json<User>,
    ctx: Database
) -> impl IntoResponse {   
    let [address, signature, nonce] = [payload.address, payload.signature, payload.nonce];

    let pubkey = utils::get_pubkey::get_pubkey(address.clone(), nonce.clone(), signature.clone());

    match pubkey {
        // * If the get_pubkey() request succeeded, go on
        Ok(pubkey) => {
            println!("{} | {}", &pubkey.to_uppercase(), &address.to_uppercase());
            println!("{}", &pubkey.to_uppercase() == &address.to_uppercase());
            if &pubkey.to_uppercase() == &address.to_uppercase() {
                let current_utc_time = Utc::now();
                let upsert = ctx.users().upsert(users::address::equals(String::from(&address)), users::create(
                    String::from(&address),
                    String::from(&signature),
                    String::from(&nonce),
                    DateTime::from(current_utc_time),
                    vec![]
                ), vec![
                    users::signature::set(String::from(&signature)),
                    users::nonce::set(String::from(&nonce)),
                    users::updated_on::set(Some(DateTime::from(current_utc_time)))
                ]).exec().await;

                match upsert {
                    Ok(data) => {
                        // * Sign JWT
                        
                        return (StatusCode::OK, Json(json!({"aaaa": "bbbbb"})))
                    }
                    Err(_) => {
                        let error_data = Data {
                            token: None
                        };

                        let error_struct = EntryError {
                            status: StatusCodes::ServerError,
                            data: error_data,
                            message: String::from("")
                        };

                        return (StatusCode::INTERNAL_SERVER_ERROR, Json(json!(error_struct)))
                    }
                }
            }
            else {
                println!("error??????? wtf?????");  
                let error_data = Data {
                    token: None
                };

                let error_struct = EntryError {
                    status: StatusCodes::Unauthorized,
                    data: error_data,
                    message: String::from("")
                };

                return (StatusCode::UNAUTHORIZED, Json(json!(error_struct)))
            }
        }
        
        // * If the get_pubkey() request failed, return an Error
        Err(e) => {
            println!("{}", e);
            let error_data = Data {
                token: None
            };
    
            let error_struct = EntryError {
                status: StatusCodes::ServerError,
                data: error_data,
                message: String::from("")
            };

            return (StatusCode::BAD_REQUEST, Json(json!(error_struct)))
        }
    }

}

// Code generated by Prisma Client Rust. DO NOT EDIT

#![allow(warnings, unused)]
static DATAMODEL_STR : & 'static str = "generator client {\n  provider = \"cargo prisma\"\n  output = \"../src/prisma.rs\"\n}\n\ndatasource db {\n  provider = \"postgresql\"\n  url      = env(\"DATABASE_URL\")\n}\n\nmodel stores {\n  store_id          String    @id @db.VarChar(52)\n  creator           String    @db.VarChar(150)\n  store_name        String    @db.VarChar(80)\n  store_description String    @db.VarChar(256)\n  store_tier        String    @db.VarChar(25)\n  store_ip          String?   @db.VarChar(90)\n  store_domain      String?   @db.VarChar(500)\n  created_on        DateTime  @db.Timestamptz(6)\n  updated_on        DateTime? @db.Timestamptz(6)\n}\n\nmodel users {\n  address    String    @id @db.VarChar(300)\n  signature  String    @db.VarChar(300)\n  nonce      String    @db.VarChar(100)\n  created_on DateTime  @db.Timestamptz(6)\n  updated_on DateTime? @db.Timestamptz(6)\n}" ;
static DATABASE_STR: &'static str = "postgresql";
pub async fn new_client() -> Result<PrismaClient, ::prisma_client_rust::NewClientError> {
    let config = ::prisma_client_rust::datamodel::parse_configuration(DATAMODEL_STR)?.subject;
    let source = config
        .datasources
        .first()
        .expect("Please supply a datasource in your schema.prisma file");
    let url = if let Some(url) = source.load_shadow_database_url()? {
        url
    } else {
        source.load_url(|key| std::env::var(key).ok())?
    };
    let url = if url.starts_with("file:") {
        let path = url.split(":").nth(1).unwrap();
        if std::path::Path::new("./schema.prisma").exists() {
            url
        } else if std::path::Path::new("./prisma/schema.prisma").exists() {
            format!("file:./prisma/{}", path)
        } else {
            url
        }
    } else {
        url
    };
    new_client_with_url(&url).await
}
pub async fn new_client_with_url(
    url: &str,
) -> Result<PrismaClient, ::prisma_client_rust::NewClientError> {
    let config = ::prisma_client_rust::datamodel::parse_configuration(DATAMODEL_STR)?.subject;
    let source = config
        .datasources
        .first()
        .expect("Please supply a datasource in your schema.prisma file");
    let (db_name, executor) =
        ::prisma_client_rust::query_core::executor::load(&source, &[], &url).await?;
    let internal_model =
        ::prisma_client_rust::prisma_models::InternalDataModelBuilder::new(DATAMODEL_STR)
            .build(db_name);
    let query_schema = std::sync::Arc::new(prisma_client_rust::query_core::schema_builder::build(
        internal_model,
        true,
        source.capabilities(),
        vec![],
        source.referential_integrity(),
    ));
    executor.primary_connector().get_connection().await?;
    Ok(PrismaClient::_new(executor, query_schema))
}
pub mod stores {
    use super::_prisma::*;
    use super::*;
    pub mod store_id {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: String) -> T {
            UniqueWhereParam::StoreIdEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::StoreId(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::StoreIdInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::StoreIdNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::StoreIdLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::StoreIdLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::StoreIdGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::StoreIdGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::StoreIdContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::StoreIdStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::StoreIdEndsWith(value)
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::StoreIdMode(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::StoreIdNot(value)
        }
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetStoreId(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::StoreId(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("store_id").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::StoreId(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("store_id").build()
            }
        }
    }
    pub mod creator {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::CreatorEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Creator(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::CreatorInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::CreatorNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::CreatorLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::CreatorLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::CreatorGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::CreatorGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::CreatorContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::CreatorStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::CreatorEndsWith(value)
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::CreatorMode(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::CreatorNot(value)
        }
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetCreator(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Creator(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("creator").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Creator(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("creator").build()
            }
        }
    }
    pub mod store_name {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::StoreNameEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::StoreName(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::StoreNameInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::StoreNameNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::StoreNameLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::StoreNameLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::StoreNameGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::StoreNameGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::StoreNameContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::StoreNameStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::StoreNameEndsWith(value)
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::StoreNameMode(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::StoreNameNot(value)
        }
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetStoreName(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::StoreName(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("store_name").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::StoreName(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("store_name").build()
            }
        }
    }
    pub mod store_description {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::StoreDescriptionEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::StoreDescription(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::StoreDescriptionInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::StoreDescriptionNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::StoreDescriptionLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::StoreDescriptionLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::StoreDescriptionGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::StoreDescriptionGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::StoreDescriptionContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::StoreDescriptionStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::StoreDescriptionEndsWith(value)
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::StoreDescriptionMode(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::StoreDescriptionNot(value)
        }
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetStoreDescription(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::StoreDescription(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("store_description").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::StoreDescription(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("store_description").build()
            }
        }
    }
    pub mod store_tier {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::StoreTierEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::StoreTier(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::StoreTierInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::StoreTierNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::StoreTierLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::StoreTierLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::StoreTierGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::StoreTierGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::StoreTierContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::StoreTierStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::StoreTierEndsWith(value)
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::StoreTierMode(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::StoreTierNot(value)
        }
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetStoreTier(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::StoreTier(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("store_tier").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::StoreTier(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("store_tier").build()
            }
        }
    }
    pub mod store_ip {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: Option<String>) -> T {
            Set(value).into()
        }
        pub fn equals(value: Option<String>) -> WhereParam {
            WhereParam::StoreIpEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::StoreIp(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::StoreIpInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::StoreIpNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::StoreIpLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::StoreIpLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::StoreIpGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::StoreIpGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::StoreIpContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::StoreIpStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::StoreIpEndsWith(value)
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::StoreIpMode(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::StoreIpNot(value)
        }
        pub struct Set(pub Option<String>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetStoreIp(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::StoreIp(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("store_ip").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::StoreIp(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("store_ip").build()
            }
        }
    }
    pub mod store_domain {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: Option<String>) -> T {
            Set(value).into()
        }
        pub fn equals(value: Option<String>) -> WhereParam {
            WhereParam::StoreDomainEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::StoreDomain(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::StoreDomainInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::StoreDomainNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::StoreDomainLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::StoreDomainLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::StoreDomainGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::StoreDomainGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::StoreDomainContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::StoreDomainStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::StoreDomainEndsWith(value)
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::StoreDomainMode(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::StoreDomainNot(value)
        }
        pub struct Set(pub Option<String>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetStoreDomain(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::StoreDomain(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("store_domain").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::StoreDomain(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("store_domain").build()
            }
        }
    }
    pub mod created_on {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> T {
            Set(value).into()
        }
        pub fn equals(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::CreatedOnEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::CreatedOn(direction)
        }
        pub fn in_vec(
            value: Vec<
                ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
            >,
        ) -> WhereParam {
            WhereParam::CreatedOnInVec(value)
        }
        pub fn not_in_vec(
            value: Vec<
                ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
            >,
        ) -> WhereParam {
            WhereParam::CreatedOnNotInVec(value)
        }
        pub fn lt(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::CreatedOnLt(value)
        }
        pub fn lte(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::CreatedOnLte(value)
        }
        pub fn gt(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::CreatedOnGt(value)
        }
        pub fn gte(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::CreatedOnGte(value)
        }
        pub fn not(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::CreatedOnNot(value)
        }
        pub struct Set(
            pub ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        );
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetCreatedOn(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::CreatedOn(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("created_on").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::CreatedOn(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("created_on").build()
            }
        }
    }
    pub mod updated_on {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(
            value: Option<
                ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
            >,
        ) -> T {
            Set(value).into()
        }
        pub fn equals(
            value: Option<
                ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
            >,
        ) -> WhereParam {
            WhereParam::UpdatedOnEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::UpdatedOn(direction)
        }
        pub fn in_vec(
            value: Vec<
                ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
            >,
        ) -> WhereParam {
            WhereParam::UpdatedOnInVec(value)
        }
        pub fn not_in_vec(
            value: Vec<
                ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
            >,
        ) -> WhereParam {
            WhereParam::UpdatedOnNotInVec(value)
        }
        pub fn lt(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::UpdatedOnLt(value)
        }
        pub fn lte(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::UpdatedOnLte(value)
        }
        pub fn gt(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::UpdatedOnGt(value)
        }
        pub fn gte(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::UpdatedOnGte(value)
        }
        pub fn not(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::UpdatedOnNot(value)
        }
        pub struct Set(
            pub  Option<
                ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
            >,
        );
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetUpdatedOn(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::UpdatedOn(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("updated_on").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::UpdatedOn(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("updated_on").build()
            }
        }
    }
    pub fn _outputs() -> Vec<::prisma_client_rust::Selection> {
        [
            "store_id",
            "creator",
            "store_name",
            "store_description",
            "store_tier",
            "store_ip",
            "store_domain",
            "created_on",
            "updated_on",
        ]
        .into_iter()
        .map(|o| {
            let builder = ::prisma_client_rust::Selection::builder(o);
            builder.build()
        })
        .collect()
    }
    pub fn create(
        store_id: String,
        creator: String,
        store_name: String,
        store_description: String,
        store_tier: String,
        created_on: ::prisma_client_rust::chrono::DateTime<
            ::prisma_client_rust::chrono::FixedOffset,
        >,
        _params: Vec<SetParam>,
    ) -> (
        String,
        String,
        String,
        String,
        String,
        ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        Vec<SetParam>,
    ) {
        (
            store_id,
            creator,
            store_name,
            store_description,
            store_tier,
            created_on,
            _params,
        )
    }
    #[macro_export]
    macro_rules ! _select_stores { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $ crate :: prisma :: stores :: select ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Select (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: select :: SelectType for Select { type Data = Data ; type ModelData = $ crate :: prisma :: stores :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } use super :: * ; pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Select { Select ($ crate :: prisma :: stores :: select ! (@ selections_to_select_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { $ crate :: prisma :: stores :: select ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Select (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: select :: SelectType for Select { type Data = Data ; type ModelData = $ crate :: prisma :: stores :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Select ($ crate :: prisma :: stores :: select ! (@ selections_to_select_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect ()) } } ; (@ definitions ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { store_id , creator , store_name , store_description , store_tier , store_ip , store_domain , created_on , updated_on } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] pub struct Data { $ (pub $ field : $ crate :: prisma :: stores :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (store_id) , stringify ! (creator) , stringify ! (store_name) , stringify ! (store_description) , stringify ! (store_tier) , stringify ! (store_ip) , stringify ! (store_domain) , stringify ! (created_on) , stringify ! (updated_on)] . len ()) ? ; $ (state . serialize_field ($ crate :: prisma :: stores :: select ! (@ field_serde_name ; $ field) , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (concat ! ($ ($ crate :: prisma :: stores :: select ! (@ field_serde_name ; $ field) , ", ") , +)) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ ($ crate :: prisma :: stores :: select ! (@ field_serde_name ; $ field) => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: stores :: select ! (@ field_serde_name ; $ field))) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: stores :: select ! (@ field_serde_name ; $ field))) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["store_id" , "creator" , "store_name" , "store_description" , "store_tier" , "store_ip" , "store_domain" , "created_on" , "updated_on"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { $ crate :: prisma :: stores :: select ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; store_id) => { String } ; (@ field_type ; creator) => { String } ; (@ field_type ; store_name) => { String } ; (@ field_type ; store_description) => { String } ; (@ field_type ; store_tier) => { String } ; (@ field_type ; store_ip) => { Option < String > } ; (@ field_type ; store_domain) => { Option < String > } ; (@ field_type ; created_on) => { :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > } ; (@ field_type ; updated_on) => { Option < :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot select field nonexistent field $ field on model "Stores" , available fields are "store_id, creator, store_name, store_description, store_tier, store_ip, store_domain, created_on, updated_on")) } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; store_id) => { Into :: < $ crate :: prisma :: stores :: SelectParam > :: into ($ crate :: prisma :: stores :: store_id :: Select) } ; (@ selection_field_to_selection_param ; creator) => { Into :: < $ crate :: prisma :: stores :: SelectParam > :: into ($ crate :: prisma :: stores :: creator :: Select) } ; (@ selection_field_to_selection_param ; store_name) => { Into :: < $ crate :: prisma :: stores :: SelectParam > :: into ($ crate :: prisma :: stores :: store_name :: Select) } ; (@ selection_field_to_selection_param ; store_description) => { Into :: < $ crate :: prisma :: stores :: SelectParam > :: into ($ crate :: prisma :: stores :: store_description :: Select) } ; (@ selection_field_to_selection_param ; store_tier) => { Into :: < $ crate :: prisma :: stores :: SelectParam > :: into ($ crate :: prisma :: stores :: store_tier :: Select) } ; (@ selection_field_to_selection_param ; store_ip) => { Into :: < $ crate :: prisma :: stores :: SelectParam > :: into ($ crate :: prisma :: stores :: store_ip :: Select) } ; (@ selection_field_to_selection_param ; store_domain) => { Into :: < $ crate :: prisma :: stores :: SelectParam > :: into ($ crate :: prisma :: stores :: store_domain :: Select) } ; (@ selection_field_to_selection_param ; created_on) => { Into :: < $ crate :: prisma :: stores :: SelectParam > :: into ($ crate :: prisma :: stores :: created_on :: Select) } ; (@ selection_field_to_selection_param ; updated_on) => { Into :: < $ crate :: prisma :: stores :: SelectParam > :: into ($ crate :: prisma :: stores :: updated_on :: Select) } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_select_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ ($ crate :: prisma :: stores :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; store_id) => { "store_id" } ; (@ field_serde_name ; creator) => { "creator" } ; (@ field_serde_name ; store_name) => { "store_name" } ; (@ field_serde_name ; store_description) => { "store_description" } ; (@ field_serde_name ; store_tier) => { "store_tier" } ; (@ field_serde_name ; store_ip) => { "store_ip" } ; (@ field_serde_name ; store_domain) => { "store_domain" } ; (@ field_serde_name ; created_on) => { "created_on" } ; (@ field_serde_name ; updated_on) => { "updated_on" } ; }
    pub use _select_stores as select;
    pub enum SelectParam {
        StoreId(store_id::Select),
        Creator(creator::Select),
        StoreName(store_name::Select),
        StoreDescription(store_description::Select),
        StoreTier(store_tier::Select),
        StoreIp(store_ip::Select),
        StoreDomain(store_domain::Select),
        CreatedOn(created_on::Select),
        UpdatedOn(updated_on::Select),
    }
    impl SelectParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::StoreId(data) => data.to_selection(),
                Self::Creator(data) => data.to_selection(),
                Self::StoreName(data) => data.to_selection(),
                Self::StoreDescription(data) => data.to_selection(),
                Self::StoreTier(data) => data.to_selection(),
                Self::StoreIp(data) => data.to_selection(),
                Self::StoreDomain(data) => data.to_selection(),
                Self::CreatedOn(data) => data.to_selection(),
                Self::UpdatedOn(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _include_stores { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $ crate :: prisma :: stores :: include ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Include (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: include :: IncludeType for Include { type Data = Data ; type ModelData = $ crate :: prisma :: stores :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } use super :: * ; pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Include { let mut selections = $ crate :: prisma :: stores :: _outputs () ; selections . extend ($ crate :: prisma :: stores :: include ! (@ selections_to_include_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ())) ; Include (selections) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { $ crate :: prisma :: stores :: include ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Include (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: include :: IncludeType for Include { type Data = Data ; type ModelData = $ crate :: prisma :: stores :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Include ({ let mut selections = $ crate :: prisma :: stores :: _outputs () ; selections . extend ($ crate :: prisma :: stores :: include ! (@ selections_to_include_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ())) ; selections }) } } ; (@ definitions ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] pub struct Data { pub store_id : String , pub creator : String , pub store_name : String , pub store_description : String , pub store_tier : String , pub store_ip : Option < String > , pub store_domain : Option < String > , pub created_on : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > , pub updated_on : Option < :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > > , $ (pub $ field : $ crate :: prisma :: stores :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (store_id) , stringify ! (creator) , stringify ! (store_name) , stringify ! (store_description) , stringify ! (store_tier) , stringify ! (store_ip) , stringify ! (store_domain) , stringify ! (created_on) , stringify ! (updated_on)] . len ()) ? ; $ (state . serialize_field ($ crate :: prisma :: stores :: include ! (@ field_serde_name ; $ field) , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , store_id , creator , store_name , store_description , store_tier , store_ip , store_domain , created_on , updated_on } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (concat ! ($ ($ crate :: prisma :: stores :: include ! (@ field_serde_name ; $ field) , ", ") , + , $ crate :: prisma :: stores :: include ! (@ field_serde_name ; store_id) , ", " , $ crate :: prisma :: stores :: include ! (@ field_serde_name ; creator) , ", " , $ crate :: prisma :: stores :: include ! (@ field_serde_name ; store_name) , ", " , $ crate :: prisma :: stores :: include ! (@ field_serde_name ; store_description) , ", " , $ crate :: prisma :: stores :: include ! (@ field_serde_name ; store_tier) , ", " , $ crate :: prisma :: stores :: include ! (@ field_serde_name ; store_ip) , ", " , $ crate :: prisma :: stores :: include ! (@ field_serde_name ; store_domain) , ", " , $ crate :: prisma :: stores :: include ! (@ field_serde_name ; created_on) , ", " , $ crate :: prisma :: stores :: include ! (@ field_serde_name ; updated_on) , ", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ ($ crate :: prisma :: stores :: include ! (@ field_serde_name ; $ field) => Ok (Field :: $ field)) , * , $ crate :: prisma :: stores :: include ! (@ field_serde_name ; store_id) => Ok (Field :: store_id) , $ crate :: prisma :: stores :: include ! (@ field_serde_name ; creator) => Ok (Field :: creator) , $ crate :: prisma :: stores :: include ! (@ field_serde_name ; store_name) => Ok (Field :: store_name) , $ crate :: prisma :: stores :: include ! (@ field_serde_name ; store_description) => Ok (Field :: store_description) , $ crate :: prisma :: stores :: include ! (@ field_serde_name ; store_tier) => Ok (Field :: store_tier) , $ crate :: prisma :: stores :: include ! (@ field_serde_name ; store_ip) => Ok (Field :: store_ip) , $ crate :: prisma :: stores :: include ! (@ field_serde_name ; store_domain) => Ok (Field :: store_domain) , $ crate :: prisma :: stores :: include ! (@ field_serde_name ; created_on) => Ok (Field :: created_on) , $ crate :: prisma :: stores :: include ! (@ field_serde_name ; updated_on) => Ok (Field :: updated_on) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut store_id = None ; let mut creator = None ; let mut store_name = None ; let mut store_description = None ; let mut store_tier = None ; let mut store_ip = None ; let mut store_domain = None ; let mut created_on = None ; let mut updated_on = None ; while let Some (key) = map . next_key () ? { match key { Field :: store_id => { if store_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: stores :: include ! (@ field_serde_name ; store_id))) ; } store_id = Some (map . next_value () ?) ; } Field :: creator => { if creator . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: stores :: include ! (@ field_serde_name ; creator))) ; } creator = Some (map . next_value () ?) ; } Field :: store_name => { if store_name . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: stores :: include ! (@ field_serde_name ; store_name))) ; } store_name = Some (map . next_value () ?) ; } Field :: store_description => { if store_description . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: stores :: include ! (@ field_serde_name ; store_description))) ; } store_description = Some (map . next_value () ?) ; } Field :: store_tier => { if store_tier . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: stores :: include ! (@ field_serde_name ; store_tier))) ; } store_tier = Some (map . next_value () ?) ; } Field :: store_ip => { if store_ip . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: stores :: include ! (@ field_serde_name ; store_ip))) ; } store_ip = Some (map . next_value () ?) ; } Field :: store_domain => { if store_domain . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: stores :: include ! (@ field_serde_name ; store_domain))) ; } store_domain = Some (map . next_value () ?) ; } Field :: created_on => { if created_on . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: stores :: include ! (@ field_serde_name ; created_on))) ; } created_on = Some (map . next_value () ?) ; } Field :: updated_on => { if updated_on . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: stores :: include ! (@ field_serde_name ; updated_on))) ; } updated_on = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: stores :: include ! (@ field_serde_name ; $ field))) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: stores :: include ! (@ field_serde_name ; $ field))) ? ;) * let store_id = store_id . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: stores :: include ! (@ field_serde_name ; store_id))) ? ; let creator = creator . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: stores :: include ! (@ field_serde_name ; creator))) ? ; let store_name = store_name . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: stores :: include ! (@ field_serde_name ; store_name))) ? ; let store_description = store_description . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: stores :: include ! (@ field_serde_name ; store_description))) ? ; let store_tier = store_tier . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: stores :: include ! (@ field_serde_name ; store_tier))) ? ; let store_ip = store_ip . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: stores :: include ! (@ field_serde_name ; store_ip))) ? ; let store_domain = store_domain . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: stores :: include ! (@ field_serde_name ; store_domain))) ? ; let created_on = created_on . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: stores :: include ! (@ field_serde_name ; created_on))) ? ; let updated_on = updated_on . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: stores :: include ! (@ field_serde_name ; updated_on))) ? ; Ok (Data { store_id , creator , store_name , store_description , store_tier , store_ip , store_domain , created_on , updated_on , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["store_id" , "creator" , "store_name" , "store_description" , "store_tier" , "store_ip" , "store_domain" , "created_on" , "updated_on"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { $ crate :: prisma :: stores :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Stores" , available relations are "")) } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_include_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ ($ crate :: prisma :: stores :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; store_id) => { "store_id" } ; (@ field_serde_name ; creator) => { "creator" } ; (@ field_serde_name ; store_name) => { "store_name" } ; (@ field_serde_name ; store_description) => { "store_description" } ; (@ field_serde_name ; store_tier) => { "store_tier" } ; (@ field_serde_name ; store_ip) => { "store_ip" } ; (@ field_serde_name ; store_domain) => { "store_domain" } ; (@ field_serde_name ; created_on) => { "created_on" } ; (@ field_serde_name ; updated_on) => { "updated_on" } ; }
    pub use _include_stores as include;
    pub enum IncludeParam {
        StoreId(store_id::Include),
        Creator(creator::Include),
        StoreName(store_name::Include),
        StoreDescription(store_description::Include),
        StoreTier(store_tier::Include),
        StoreIp(store_ip::Include),
        StoreDomain(store_domain::Include),
        CreatedOn(created_on::Include),
        UpdatedOn(updated_on::Include),
    }
    impl IncludeParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::StoreId(data) => data.to_selection(),
                Self::Creator(data) => data.to_selection(),
                Self::StoreName(data) => data.to_selection(),
                Self::StoreDescription(data) => data.to_selection(),
                Self::StoreTier(data) => data.to_selection(),
                Self::StoreIp(data) => data.to_selection(),
                Self::StoreDomain(data) => data.to_selection(),
                Self::CreatedOn(data) => data.to_selection(),
                Self::UpdatedOn(data) => data.to_selection(),
            }
        }
    }
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub struct Data {
        #[serde(rename = "store_id")]
        pub store_id: String,
        #[serde(rename = "creator")]
        pub creator: String,
        #[serde(rename = "store_name")]
        pub store_name: String,
        #[serde(rename = "store_description")]
        pub store_description: String,
        #[serde(rename = "store_tier")]
        pub store_tier: String,
        #[serde(rename = "store_ip")]
        pub store_ip: Option<String>,
        #[serde(rename = "store_domain")]
        pub store_domain: Option<String>,
        #[serde(rename = "created_on")]
        pub created_on:
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        #[serde(rename = "updated_on")]
        pub updated_on: Option<
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        >,
    }
    impl Data {}
    #[derive(Clone)]
    pub enum WithParam {}
    impl Into<::prisma_client_rust::Selection> for WithParam {
        fn into(self) -> ::prisma_client_rust::Selection {
            match self {}
        }
    }
    #[derive(Clone)]
    pub enum SetParam {
        SetStoreId(String),
        SetCreator(String),
        SetStoreName(String),
        SetStoreDescription(String),
        SetStoreTier(String),
        SetStoreIp(Option<String>),
        SetStoreDomain(Option<String>),
        SetCreatedOn(
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        ),
        SetUpdatedOn(
            Option<
                ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
            >,
        ),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for SetParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self {
                SetParam::SetStoreId(value) => (
                    "store_id".to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::SetCreator(value) => (
                    "creator".to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::SetStoreName(value) => (
                    "store_name".to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::SetStoreDescription(value) => (
                    "store_description".to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::SetStoreTier(value) => (
                    "store_tier".to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::SetStoreIp(value) => (
                    "store_ip".to_string(),
                    value
                        .map(|value| ::prisma_client_rust::PrismaValue::String(value))
                        .unwrap_or(::prisma_client_rust::PrismaValue::Null),
                ),
                SetParam::SetStoreDomain(value) => (
                    "store_domain".to_string(),
                    value
                        .map(|value| ::prisma_client_rust::PrismaValue::String(value))
                        .unwrap_or(::prisma_client_rust::PrismaValue::Null),
                ),
                SetParam::SetCreatedOn(value) => (
                    "created_on".to_string(),
                    ::prisma_client_rust::PrismaValue::DateTime(value),
                ),
                SetParam::SetUpdatedOn(value) => (
                    "updated_on".to_string(),
                    value
                        .map(|value| ::prisma_client_rust::PrismaValue::DateTime(value))
                        .unwrap_or(::prisma_client_rust::PrismaValue::Null),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum OrderByParam {
        StoreId(::prisma_client_rust::Direction),
        Creator(::prisma_client_rust::Direction),
        StoreName(::prisma_client_rust::Direction),
        StoreDescription(::prisma_client_rust::Direction),
        StoreTier(::prisma_client_rust::Direction),
        StoreIp(::prisma_client_rust::Direction),
        StoreDomain(::prisma_client_rust::Direction),
        CreatedOn(::prisma_client_rust::Direction),
        UpdatedOn(::prisma_client_rust::Direction),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self {
                Self::StoreId(direction) => (
                    "store_id".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Creator(direction) => (
                    "creator".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::StoreName(direction) => (
                    "store_name".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::StoreDescription(direction) => (
                    "store_description".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::StoreTier(direction) => (
                    "store_tier".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::StoreIp(direction) => (
                    "store_ip".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::StoreDomain(direction) => (
                    "store_domain".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::CreatedOn(direction) => (
                    "created_on".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::UpdatedOn(direction) => (
                    "updated_on".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        StoreIdEquals(String),
        StoreIdInVec(Vec<String>),
        StoreIdNotInVec(Vec<String>),
        StoreIdLt(String),
        StoreIdLte(String),
        StoreIdGt(String),
        StoreIdGte(String),
        StoreIdContains(String),
        StoreIdStartsWith(String),
        StoreIdEndsWith(String),
        StoreIdMode(QueryMode),
        StoreIdNot(String),
        CreatorEquals(String),
        CreatorInVec(Vec<String>),
        CreatorNotInVec(Vec<String>),
        CreatorLt(String),
        CreatorLte(String),
        CreatorGt(String),
        CreatorGte(String),
        CreatorContains(String),
        CreatorStartsWith(String),
        CreatorEndsWith(String),
        CreatorMode(QueryMode),
        CreatorNot(String),
        StoreNameEquals(String),
        StoreNameInVec(Vec<String>),
        StoreNameNotInVec(Vec<String>),
        StoreNameLt(String),
        StoreNameLte(String),
        StoreNameGt(String),
        StoreNameGte(String),
        StoreNameContains(String),
        StoreNameStartsWith(String),
        StoreNameEndsWith(String),
        StoreNameMode(QueryMode),
        StoreNameNot(String),
        StoreDescriptionEquals(String),
        StoreDescriptionInVec(Vec<String>),
        StoreDescriptionNotInVec(Vec<String>),
        StoreDescriptionLt(String),
        StoreDescriptionLte(String),
        StoreDescriptionGt(String),
        StoreDescriptionGte(String),
        StoreDescriptionContains(String),
        StoreDescriptionStartsWith(String),
        StoreDescriptionEndsWith(String),
        StoreDescriptionMode(QueryMode),
        StoreDescriptionNot(String),
        StoreTierEquals(String),
        StoreTierInVec(Vec<String>),
        StoreTierNotInVec(Vec<String>),
        StoreTierLt(String),
        StoreTierLte(String),
        StoreTierGt(String),
        StoreTierGte(String),
        StoreTierContains(String),
        StoreTierStartsWith(String),
        StoreTierEndsWith(String),
        StoreTierMode(QueryMode),
        StoreTierNot(String),
        StoreIpEquals(Option<String>),
        StoreIpInVec(Vec<String>),
        StoreIpNotInVec(Vec<String>),
        StoreIpLt(String),
        StoreIpLte(String),
        StoreIpGt(String),
        StoreIpGte(String),
        StoreIpContains(String),
        StoreIpStartsWith(String),
        StoreIpEndsWith(String),
        StoreIpMode(QueryMode),
        StoreIpNot(String),
        StoreDomainEquals(Option<String>),
        StoreDomainInVec(Vec<String>),
        StoreDomainNotInVec(Vec<String>),
        StoreDomainLt(String),
        StoreDomainLte(String),
        StoreDomainGt(String),
        StoreDomainGte(String),
        StoreDomainContains(String),
        StoreDomainStartsWith(String),
        StoreDomainEndsWith(String),
        StoreDomainMode(QueryMode),
        StoreDomainNot(String),
        CreatedOnEquals(
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        ),
        CreatedOnInVec(
            Vec<::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>>,
        ),
        CreatedOnNotInVec(
            Vec<::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>>,
        ),
        CreatedOnLt(
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        ),
        CreatedOnLte(
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        ),
        CreatedOnGt(
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        ),
        CreatedOnGte(
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        ),
        CreatedOnNot(
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        ),
        UpdatedOnEquals(
            Option<
                ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
            >,
        ),
        UpdatedOnInVec(
            Vec<::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>>,
        ),
        UpdatedOnNotInVec(
            Vec<::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>>,
        ),
        UpdatedOnLt(
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        ),
        UpdatedOnLte(
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        ),
        UpdatedOnGt(
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        ),
        UpdatedOnGte(
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        ),
        UpdatedOnNot(
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        ),
    }
    impl Into<::prisma_client_rust::SerializedWhere> for WhereParam {
        fn into(self) -> ::prisma_client_rust::SerializedWhere {
            match self {
                Self::Not(value) => ::prisma_client_rust::SerializedWhere::new(
                    "NOT",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        value
                            .into_iter()
                            .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                            .map(Into::into)
                            .collect(),
                    ),
                ),
                Self::Or(value) => ::prisma_client_rust::SerializedWhere::new(
                    "OR",
                    ::prisma_client_rust::SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                            .map(Into::into)
                            .map(|v| vec![v])
                            .map(::prisma_client_rust::PrismaValue::Object)
                            .collect(),
                    ),
                ),
                Self::And(value) => ::prisma_client_rust::SerializedWhere::new(
                    "AND",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        value
                            .into_iter()
                            .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                            .map(Into::into)
                            .collect(),
                    ),
                ),
                Self::StoreIdEquals(value) => ::prisma_client_rust::SerializedWhere::new(
                    "store_id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::StoreIdInVec(value) => ::prisma_client_rust::SerializedWhere::new(
                    "store_id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| ::prisma_client_rust::PrismaValue::String(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::StoreIdNotInVec(value) => ::prisma_client_rust::SerializedWhere::new(
                    "store_id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| ::prisma_client_rust::PrismaValue::String(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::StoreIdLt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "store_id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::StoreIdLte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "store_id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::StoreIdGt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "store_id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::StoreIdGte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "store_id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::StoreIdContains(value) => ::prisma_client_rust::SerializedWhere::new(
                    "store_id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "contains".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::StoreIdStartsWith(value) => ::prisma_client_rust::SerializedWhere::new(
                    "store_id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "startsWith".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::StoreIdEndsWith(value) => ::prisma_client_rust::SerializedWhere::new(
                    "store_id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "endsWith".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::StoreIdMode(value) => ::prisma_client_rust::SerializedWhere::new(
                    "store_id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "mode".to_string(),
                        ::prisma_client_rust::PrismaValue::Enum(value.to_string()),
                    )]),
                ),
                Self::StoreIdNot(value) => ::prisma_client_rust::SerializedWhere::new(
                    "store_id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::CreatorEquals(value) => ::prisma_client_rust::SerializedWhere::new(
                    "creator",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::CreatorInVec(value) => ::prisma_client_rust::SerializedWhere::new(
                    "creator",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| ::prisma_client_rust::PrismaValue::String(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::CreatorNotInVec(value) => ::prisma_client_rust::SerializedWhere::new(
                    "creator",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| ::prisma_client_rust::PrismaValue::String(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::CreatorLt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "creator",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::CreatorLte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "creator",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::CreatorGt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "creator",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::CreatorGte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "creator",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::CreatorContains(value) => ::prisma_client_rust::SerializedWhere::new(
                    "creator",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "contains".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::CreatorStartsWith(value) => ::prisma_client_rust::SerializedWhere::new(
                    "creator",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "startsWith".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::CreatorEndsWith(value) => ::prisma_client_rust::SerializedWhere::new(
                    "creator",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "endsWith".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::CreatorMode(value) => ::prisma_client_rust::SerializedWhere::new(
                    "creator",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "mode".to_string(),
                        ::prisma_client_rust::PrismaValue::Enum(value.to_string()),
                    )]),
                ),
                Self::CreatorNot(value) => ::prisma_client_rust::SerializedWhere::new(
                    "creator",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::StoreNameEquals(value) => ::prisma_client_rust::SerializedWhere::new(
                    "store_name",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::StoreNameInVec(value) => ::prisma_client_rust::SerializedWhere::new(
                    "store_name",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| ::prisma_client_rust::PrismaValue::String(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::StoreNameNotInVec(value) => ::prisma_client_rust::SerializedWhere::new(
                    "store_name",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| ::prisma_client_rust::PrismaValue::String(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::StoreNameLt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "store_name",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::StoreNameLte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "store_name",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::StoreNameGt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "store_name",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::StoreNameGte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "store_name",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::StoreNameContains(value) => ::prisma_client_rust::SerializedWhere::new(
                    "store_name",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "contains".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::StoreNameStartsWith(value) => ::prisma_client_rust::SerializedWhere::new(
                    "store_name",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "startsWith".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::StoreNameEndsWith(value) => ::prisma_client_rust::SerializedWhere::new(
                    "store_name",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "endsWith".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::StoreNameMode(value) => ::prisma_client_rust::SerializedWhere::new(
                    "store_name",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "mode".to_string(),
                        ::prisma_client_rust::PrismaValue::Enum(value.to_string()),
                    )]),
                ),
                Self::StoreNameNot(value) => ::prisma_client_rust::SerializedWhere::new(
                    "store_name",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::StoreDescriptionEquals(value) => ::prisma_client_rust::SerializedWhere::new(
                    "store_description",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::StoreDescriptionInVec(value) => ::prisma_client_rust::SerializedWhere::new(
                    "store_description",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| ::prisma_client_rust::PrismaValue::String(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::StoreDescriptionNotInVec(value) => {
                    ::prisma_client_rust::SerializedWhere::new(
                        "store_description",
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "notIn".to_string(),
                            ::prisma_client_rust::PrismaValue::List(
                                value
                                    .into_iter()
                                    .map(|v| ::prisma_client_rust::PrismaValue::String(v))
                                    .collect(),
                            ),
                        )]),
                    )
                }
                Self::StoreDescriptionLt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "store_description",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::StoreDescriptionLte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "store_description",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::StoreDescriptionGt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "store_description",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::StoreDescriptionGte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "store_description",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::StoreDescriptionContains(value) => {
                    ::prisma_client_rust::SerializedWhere::new(
                        "store_description",
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "contains".to_string(),
                            ::prisma_client_rust::PrismaValue::String(value),
                        )]),
                    )
                }
                Self::StoreDescriptionStartsWith(value) => {
                    ::prisma_client_rust::SerializedWhere::new(
                        "store_description",
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "startsWith".to_string(),
                            ::prisma_client_rust::PrismaValue::String(value),
                        )]),
                    )
                }
                Self::StoreDescriptionEndsWith(value) => {
                    ::prisma_client_rust::SerializedWhere::new(
                        "store_description",
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "endsWith".to_string(),
                            ::prisma_client_rust::PrismaValue::String(value),
                        )]),
                    )
                }
                Self::StoreDescriptionMode(value) => ::prisma_client_rust::SerializedWhere::new(
                    "store_description",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "mode".to_string(),
                        ::prisma_client_rust::PrismaValue::Enum(value.to_string()),
                    )]),
                ),
                Self::StoreDescriptionNot(value) => ::prisma_client_rust::SerializedWhere::new(
                    "store_description",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::StoreTierEquals(value) => ::prisma_client_rust::SerializedWhere::new(
                    "store_tier",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::StoreTierInVec(value) => ::prisma_client_rust::SerializedWhere::new(
                    "store_tier",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| ::prisma_client_rust::PrismaValue::String(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::StoreTierNotInVec(value) => ::prisma_client_rust::SerializedWhere::new(
                    "store_tier",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| ::prisma_client_rust::PrismaValue::String(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::StoreTierLt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "store_tier",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::StoreTierLte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "store_tier",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::StoreTierGt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "store_tier",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::StoreTierGte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "store_tier",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::StoreTierContains(value) => ::prisma_client_rust::SerializedWhere::new(
                    "store_tier",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "contains".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::StoreTierStartsWith(value) => ::prisma_client_rust::SerializedWhere::new(
                    "store_tier",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "startsWith".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::StoreTierEndsWith(value) => ::prisma_client_rust::SerializedWhere::new(
                    "store_tier",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "endsWith".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::StoreTierMode(value) => ::prisma_client_rust::SerializedWhere::new(
                    "store_tier",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "mode".to_string(),
                        ::prisma_client_rust::PrismaValue::Enum(value.to_string()),
                    )]),
                ),
                Self::StoreTierNot(value) => ::prisma_client_rust::SerializedWhere::new(
                    "store_tier",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::StoreIpEquals(value) => ::prisma_client_rust::SerializedWhere::new(
                    "store_ip",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        value
                            .map(|value| ::prisma_client_rust::PrismaValue::String(value))
                            .unwrap_or(::prisma_client_rust::PrismaValue::Null),
                    )]),
                ),
                Self::StoreIpInVec(value) => ::prisma_client_rust::SerializedWhere::new(
                    "store_ip",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| ::prisma_client_rust::PrismaValue::String(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::StoreIpNotInVec(value) => ::prisma_client_rust::SerializedWhere::new(
                    "store_ip",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| ::prisma_client_rust::PrismaValue::String(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::StoreIpLt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "store_ip",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::StoreIpLte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "store_ip",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::StoreIpGt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "store_ip",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::StoreIpGte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "store_ip",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::StoreIpContains(value) => ::prisma_client_rust::SerializedWhere::new(
                    "store_ip",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "contains".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::StoreIpStartsWith(value) => ::prisma_client_rust::SerializedWhere::new(
                    "store_ip",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "startsWith".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::StoreIpEndsWith(value) => ::prisma_client_rust::SerializedWhere::new(
                    "store_ip",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "endsWith".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::StoreIpMode(value) => ::prisma_client_rust::SerializedWhere::new(
                    "store_ip",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "mode".to_string(),
                        ::prisma_client_rust::PrismaValue::Enum(value.to_string()),
                    )]),
                ),
                Self::StoreIpNot(value) => ::prisma_client_rust::SerializedWhere::new(
                    "store_ip",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::StoreDomainEquals(value) => ::prisma_client_rust::SerializedWhere::new(
                    "store_domain",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        value
                            .map(|value| ::prisma_client_rust::PrismaValue::String(value))
                            .unwrap_or(::prisma_client_rust::PrismaValue::Null),
                    )]),
                ),
                Self::StoreDomainInVec(value) => ::prisma_client_rust::SerializedWhere::new(
                    "store_domain",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| ::prisma_client_rust::PrismaValue::String(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::StoreDomainNotInVec(value) => ::prisma_client_rust::SerializedWhere::new(
                    "store_domain",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| ::prisma_client_rust::PrismaValue::String(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::StoreDomainLt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "store_domain",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::StoreDomainLte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "store_domain",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::StoreDomainGt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "store_domain",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::StoreDomainGte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "store_domain",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::StoreDomainContains(value) => ::prisma_client_rust::SerializedWhere::new(
                    "store_domain",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "contains".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::StoreDomainStartsWith(value) => ::prisma_client_rust::SerializedWhere::new(
                    "store_domain",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "startsWith".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::StoreDomainEndsWith(value) => ::prisma_client_rust::SerializedWhere::new(
                    "store_domain",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "endsWith".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::StoreDomainMode(value) => ::prisma_client_rust::SerializedWhere::new(
                    "store_domain",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "mode".to_string(),
                        ::prisma_client_rust::PrismaValue::Enum(value.to_string()),
                    )]),
                ),
                Self::StoreDomainNot(value) => ::prisma_client_rust::SerializedWhere::new(
                    "store_domain",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::CreatedOnEquals(value) => ::prisma_client_rust::SerializedWhere::new(
                    "created_on",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        ::prisma_client_rust::PrismaValue::DateTime(value),
                    )]),
                ),
                Self::CreatedOnInVec(value) => ::prisma_client_rust::SerializedWhere::new(
                    "created_on",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| ::prisma_client_rust::PrismaValue::DateTime(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::CreatedOnNotInVec(value) => ::prisma_client_rust::SerializedWhere::new(
                    "created_on",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| ::prisma_client_rust::PrismaValue::DateTime(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::CreatedOnLt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "created_on",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        ::prisma_client_rust::PrismaValue::DateTime(value),
                    )]),
                ),
                Self::CreatedOnLte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "created_on",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        ::prisma_client_rust::PrismaValue::DateTime(value),
                    )]),
                ),
                Self::CreatedOnGt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "created_on",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        ::prisma_client_rust::PrismaValue::DateTime(value),
                    )]),
                ),
                Self::CreatedOnGte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "created_on",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        ::prisma_client_rust::PrismaValue::DateTime(value),
                    )]),
                ),
                Self::CreatedOnNot(value) => ::prisma_client_rust::SerializedWhere::new(
                    "created_on",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        ::prisma_client_rust::PrismaValue::DateTime(value),
                    )]),
                ),
                Self::UpdatedOnEquals(value) => ::prisma_client_rust::SerializedWhere::new(
                    "updated_on",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        value
                            .map(|value| ::prisma_client_rust::PrismaValue::DateTime(value))
                            .unwrap_or(::prisma_client_rust::PrismaValue::Null),
                    )]),
                ),
                Self::UpdatedOnInVec(value) => ::prisma_client_rust::SerializedWhere::new(
                    "updated_on",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| ::prisma_client_rust::PrismaValue::DateTime(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::UpdatedOnNotInVec(value) => ::prisma_client_rust::SerializedWhere::new(
                    "updated_on",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| ::prisma_client_rust::PrismaValue::DateTime(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::UpdatedOnLt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "updated_on",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        ::prisma_client_rust::PrismaValue::DateTime(value),
                    )]),
                ),
                Self::UpdatedOnLte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "updated_on",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        ::prisma_client_rust::PrismaValue::DateTime(value),
                    )]),
                ),
                Self::UpdatedOnGt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "updated_on",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        ::prisma_client_rust::PrismaValue::DateTime(value),
                    )]),
                ),
                Self::UpdatedOnGte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "updated_on",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        ::prisma_client_rust::PrismaValue::DateTime(value),
                    )]),
                ),
                Self::UpdatedOnNot(value) => ::prisma_client_rust::SerializedWhere::new(
                    "updated_on",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        ::prisma_client_rust::PrismaValue::DateTime(value),
                    )]),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum UniqueWhereParam {
        StoreIdEquals(String),
    }
    impl From<UniqueWhereParam> for WhereParam {
        fn from(value: UniqueWhereParam) -> Self {
            match value {
                UniqueWhereParam::StoreIdEquals(value) => Self::StoreIdEquals(value),
            }
        }
    }
    impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
        fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
            match op {
                ::prisma_client_rust::Operator::Not(value) => Self::Not(value),
                ::prisma_client_rust::Operator::And(value) => Self::And(value),
                ::prisma_client_rust::Operator::Or(value) => Self::Or(value),
            }
        }
    }
    pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<WithParam>;
    pub type ManyArgs =
        ::prisma_client_rust::ManyArgs<WhereParam, WithParam, OrderByParam, UniqueWhereParam>;
    pub type Count<'a> =
        ::prisma_client_rust::Count<'a, WhereParam, OrderByParam, UniqueWhereParam>;
    pub type Create<'a> = ::prisma_client_rust::Create<'a, SetParam, WithParam, Data>;
    pub type CreateMany<'a> = ::prisma_client_rust::CreateMany<'a, SetParam>;
    pub type FindUnique<'a> =
        ::prisma_client_rust::FindUnique<'a, WhereParam, WithParam, SetParam, Data>;
    pub type FindMany<'a> = ::prisma_client_rust::FindMany<
        'a,
        WhereParam,
        WithParam,
        OrderByParam,
        UniqueWhereParam,
        SetParam,
        Data,
    >;
    pub type FindFirst<'a> = ::prisma_client_rust::FindFirst<
        'a,
        WhereParam,
        WithParam,
        OrderByParam,
        UniqueWhereParam,
        Data,
    >;
    pub type Update<'a> = ::prisma_client_rust::Update<'a, WhereParam, WithParam, SetParam, Data>;
    pub type UpdateMany<'a> = ::prisma_client_rust::UpdateMany<'a, WhereParam, SetParam>;
    pub type Upsert<'a> = ::prisma_client_rust::Upsert<'a, WhereParam, SetParam, WithParam, Data>;
    pub type Delete<'a> = ::prisma_client_rust::Delete<'a, WhereParam, WithParam, Data>;
    pub type DeleteMany<'a> = ::prisma_client_rust::DeleteMany<'a, WhereParam>;
    pub struct Actions<'a> {
        pub client: &'a PrismaClient,
    }
    impl<'a> Actions<'a> {
        pub fn find_unique(self, _where: UniqueWhereParam) -> FindUnique<'a> {
            FindUnique::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("stores", _outputs()),
                _where.into(),
            )
        }
        pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirst<'a> {
            FindFirst::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("stores", _outputs()),
                _where,
            )
        }
        pub fn find_many(self, _where: Vec<WhereParam>) -> FindMany<'a> {
            FindMany::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("stores", _outputs()),
                _where,
            )
        }
        pub fn create(
            self,
            store_id: String,
            creator: String,
            store_name: String,
            store_description: String,
            store_tier: String,
            created_on: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
            mut _params: Vec<SetParam>,
        ) -> Create<'a> {
            _params.push(store_id::set(store_id));
            _params.push(creator::set(creator));
            _params.push(store_name::set(store_name));
            _params.push(store_description::set(store_description));
            _params.push(store_tier::set(store_tier));
            _params.push(created_on::set(created_on));
            Create::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("stores", _outputs()),
                _params,
            )
        }
        pub fn create_many(
            self,
            data: Vec<(
                String,
                String,
                String,
                String,
                String,
                ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
                Vec<SetParam>,
            )>,
        ) -> CreateMany<'a> {
            let data = data
                .into_iter()
                .map(
                    |(
                        store_id,
                        creator,
                        store_name,
                        store_description,
                        store_tier,
                        created_on,
                        mut _params,
                    )| {
                        _params.push(store_id::set(store_id));
                        _params.push(creator::set(creator));
                        _params.push(store_name::set(store_name));
                        _params.push(store_description::set(store_description));
                        _params.push(store_tier::set(store_tier));
                        _params.push(created_on::set(created_on));
                        _params
                    },
                )
                .collect();
            CreateMany::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("stores", _outputs()),
                data,
            )
        }
        pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> Update<'a> {
            Update::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("stores", _outputs()),
                _where.into(),
                _params,
                vec![],
            )
        }
        pub fn update_many(
            self,
            _where: Vec<WhereParam>,
            _params: Vec<SetParam>,
        ) -> UpdateMany<'a> {
            UpdateMany::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("stores", _outputs()),
                _where,
                _params,
            )
        }
        pub fn upsert(
            self,
            _where: UniqueWhereParam,
            (store_id , creator , store_name , store_description , store_tier , created_on , mut _params) : (String , String , String , String , String , :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > , Vec < SetParam >),
            _update: Vec<SetParam>,
        ) -> Upsert<'a> {
            _params.push(store_id::set(store_id));
            _params.push(creator::set(creator));
            _params.push(store_name::set(store_name));
            _params.push(store_description::set(store_description));
            _params.push(store_tier::set(store_tier));
            _params.push(created_on::set(created_on));
            Upsert::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("stores", _outputs()),
                _where.into(),
                _params,
                _update,
            )
        }
        pub fn delete(self, _where: UniqueWhereParam) -> Delete<'a> {
            Delete::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("stores", _outputs()),
                _where.into(),
                vec![],
            )
        }
        pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteMany<'a> {
            DeleteMany::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("stores", _outputs()),
                _where.into(),
            )
        }
        pub fn count(self, _where: Vec<WhereParam>) -> Count<'a> {
            Count::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("stores", _outputs()),
                vec![],
            )
        }
    }
}
pub mod users {
    use super::_prisma::*;
    use super::*;
    pub mod address {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: String) -> T {
            UniqueWhereParam::AddressEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Address(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::AddressInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::AddressNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::AddressLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::AddressLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::AddressGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::AddressGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::AddressContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::AddressStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::AddressEndsWith(value)
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::AddressMode(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::AddressNot(value)
        }
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetAddress(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Address(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("address").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Address(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("address").build()
            }
        }
    }
    pub mod signature {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::SignatureEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Signature(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::SignatureInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::SignatureNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::SignatureLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::SignatureLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::SignatureGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::SignatureGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::SignatureContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::SignatureStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::SignatureEndsWith(value)
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::SignatureMode(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::SignatureNot(value)
        }
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetSignature(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Signature(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("signature").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Signature(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("signature").build()
            }
        }
    }
    pub mod nonce {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::NonceEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Nonce(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::NonceInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::NonceNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::NonceLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::NonceLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::NonceGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::NonceGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::NonceContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::NonceStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::NonceEndsWith(value)
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::NonceMode(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::NonceNot(value)
        }
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetNonce(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Nonce(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("nonce").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Nonce(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("nonce").build()
            }
        }
    }
    pub mod created_on {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> T {
            Set(value).into()
        }
        pub fn equals(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::CreatedOnEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::CreatedOn(direction)
        }
        pub fn in_vec(
            value: Vec<
                ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
            >,
        ) -> WhereParam {
            WhereParam::CreatedOnInVec(value)
        }
        pub fn not_in_vec(
            value: Vec<
                ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
            >,
        ) -> WhereParam {
            WhereParam::CreatedOnNotInVec(value)
        }
        pub fn lt(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::CreatedOnLt(value)
        }
        pub fn lte(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::CreatedOnLte(value)
        }
        pub fn gt(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::CreatedOnGt(value)
        }
        pub fn gte(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::CreatedOnGte(value)
        }
        pub fn not(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::CreatedOnNot(value)
        }
        pub struct Set(
            pub ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        );
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetCreatedOn(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::CreatedOn(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("created_on").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::CreatedOn(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("created_on").build()
            }
        }
    }
    pub mod updated_on {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(
            value: Option<
                ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
            >,
        ) -> T {
            Set(value).into()
        }
        pub fn equals(
            value: Option<
                ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
            >,
        ) -> WhereParam {
            WhereParam::UpdatedOnEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::UpdatedOn(direction)
        }
        pub fn in_vec(
            value: Vec<
                ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
            >,
        ) -> WhereParam {
            WhereParam::UpdatedOnInVec(value)
        }
        pub fn not_in_vec(
            value: Vec<
                ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
            >,
        ) -> WhereParam {
            WhereParam::UpdatedOnNotInVec(value)
        }
        pub fn lt(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::UpdatedOnLt(value)
        }
        pub fn lte(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::UpdatedOnLte(value)
        }
        pub fn gt(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::UpdatedOnGt(value)
        }
        pub fn gte(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::UpdatedOnGte(value)
        }
        pub fn not(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::UpdatedOnNot(value)
        }
        pub struct Set(
            pub  Option<
                ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
            >,
        );
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetUpdatedOn(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::UpdatedOn(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("updated_on").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::UpdatedOn(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("updated_on").build()
            }
        }
    }
    pub fn _outputs() -> Vec<::prisma_client_rust::Selection> {
        ["address", "signature", "nonce", "created_on", "updated_on"]
            .into_iter()
            .map(|o| {
                let builder = ::prisma_client_rust::Selection::builder(o);
                builder.build()
            })
            .collect()
    }
    pub fn create(
        address: String,
        signature: String,
        nonce: String,
        created_on: ::prisma_client_rust::chrono::DateTime<
            ::prisma_client_rust::chrono::FixedOffset,
        >,
        _params: Vec<SetParam>,
    ) -> (
        String,
        String,
        String,
        ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        Vec<SetParam>,
    ) {
        (address, signature, nonce, created_on, _params)
    }
    #[macro_export]
    macro_rules ! _select_users { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $ crate :: prisma :: users :: select ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Select (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: select :: SelectType for Select { type Data = Data ; type ModelData = $ crate :: prisma :: users :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } use super :: * ; pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Select { Select ($ crate :: prisma :: users :: select ! (@ selections_to_select_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { $ crate :: prisma :: users :: select ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Select (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: select :: SelectType for Select { type Data = Data ; type ModelData = $ crate :: prisma :: users :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Select ($ crate :: prisma :: users :: select ! (@ selections_to_select_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect ()) } } ; (@ definitions ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { address , signature , nonce , created_on , updated_on } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] pub struct Data { $ (pub $ field : $ crate :: prisma :: users :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (address) , stringify ! (signature) , stringify ! (nonce) , stringify ! (created_on) , stringify ! (updated_on)] . len ()) ? ; $ (state . serialize_field ($ crate :: prisma :: users :: select ! (@ field_serde_name ; $ field) , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (concat ! ($ ($ crate :: prisma :: users :: select ! (@ field_serde_name ; $ field) , ", ") , +)) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ ($ crate :: prisma :: users :: select ! (@ field_serde_name ; $ field) => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: users :: select ! (@ field_serde_name ; $ field))) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: users :: select ! (@ field_serde_name ; $ field))) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["address" , "signature" , "nonce" , "created_on" , "updated_on"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { $ crate :: prisma :: users :: select ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; address) => { String } ; (@ field_type ; signature) => { String } ; (@ field_type ; nonce) => { String } ; (@ field_type ; created_on) => { :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > } ; (@ field_type ; updated_on) => { Option < :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot select field nonexistent field $ field on model "Users" , available fields are "address, signature, nonce, created_on, updated_on")) } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; address) => { Into :: < $ crate :: prisma :: users :: SelectParam > :: into ($ crate :: prisma :: users :: address :: Select) } ; (@ selection_field_to_selection_param ; signature) => { Into :: < $ crate :: prisma :: users :: SelectParam > :: into ($ crate :: prisma :: users :: signature :: Select) } ; (@ selection_field_to_selection_param ; nonce) => { Into :: < $ crate :: prisma :: users :: SelectParam > :: into ($ crate :: prisma :: users :: nonce :: Select) } ; (@ selection_field_to_selection_param ; created_on) => { Into :: < $ crate :: prisma :: users :: SelectParam > :: into ($ crate :: prisma :: users :: created_on :: Select) } ; (@ selection_field_to_selection_param ; updated_on) => { Into :: < $ crate :: prisma :: users :: SelectParam > :: into ($ crate :: prisma :: users :: updated_on :: Select) } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_select_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ ($ crate :: prisma :: users :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; address) => { "address" } ; (@ field_serde_name ; signature) => { "signature" } ; (@ field_serde_name ; nonce) => { "nonce" } ; (@ field_serde_name ; created_on) => { "created_on" } ; (@ field_serde_name ; updated_on) => { "updated_on" } ; }
    pub use _select_users as select;
    pub enum SelectParam {
        Address(address::Select),
        Signature(signature::Select),
        Nonce(nonce::Select),
        CreatedOn(created_on::Select),
        UpdatedOn(updated_on::Select),
    }
    impl SelectParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Address(data) => data.to_selection(),
                Self::Signature(data) => data.to_selection(),
                Self::Nonce(data) => data.to_selection(),
                Self::CreatedOn(data) => data.to_selection(),
                Self::UpdatedOn(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _include_users { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $ crate :: prisma :: users :: include ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Include (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: include :: IncludeType for Include { type Data = Data ; type ModelData = $ crate :: prisma :: users :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } use super :: * ; pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Include { let mut selections = $ crate :: prisma :: users :: _outputs () ; selections . extend ($ crate :: prisma :: users :: include ! (@ selections_to_include_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ())) ; Include (selections) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { $ crate :: prisma :: users :: include ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Include (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: include :: IncludeType for Include { type Data = Data ; type ModelData = $ crate :: prisma :: users :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Include ({ let mut selections = $ crate :: prisma :: users :: _outputs () ; selections . extend ($ crate :: prisma :: users :: include ! (@ selections_to_include_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ())) ; selections }) } } ; (@ definitions ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] pub struct Data { pub address : String , pub signature : String , pub nonce : String , pub created_on : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > , pub updated_on : Option < :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > > , $ (pub $ field : $ crate :: prisma :: users :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (address) , stringify ! (signature) , stringify ! (nonce) , stringify ! (created_on) , stringify ! (updated_on)] . len ()) ? ; $ (state . serialize_field ($ crate :: prisma :: users :: include ! (@ field_serde_name ; $ field) , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , address , signature , nonce , created_on , updated_on } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (concat ! ($ ($ crate :: prisma :: users :: include ! (@ field_serde_name ; $ field) , ", ") , + , $ crate :: prisma :: users :: include ! (@ field_serde_name ; address) , ", " , $ crate :: prisma :: users :: include ! (@ field_serde_name ; signature) , ", " , $ crate :: prisma :: users :: include ! (@ field_serde_name ; nonce) , ", " , $ crate :: prisma :: users :: include ! (@ field_serde_name ; created_on) , ", " , $ crate :: prisma :: users :: include ! (@ field_serde_name ; updated_on) , ", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ ($ crate :: prisma :: users :: include ! (@ field_serde_name ; $ field) => Ok (Field :: $ field)) , * , $ crate :: prisma :: users :: include ! (@ field_serde_name ; address) => Ok (Field :: address) , $ crate :: prisma :: users :: include ! (@ field_serde_name ; signature) => Ok (Field :: signature) , $ crate :: prisma :: users :: include ! (@ field_serde_name ; nonce) => Ok (Field :: nonce) , $ crate :: prisma :: users :: include ! (@ field_serde_name ; created_on) => Ok (Field :: created_on) , $ crate :: prisma :: users :: include ! (@ field_serde_name ; updated_on) => Ok (Field :: updated_on) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut address = None ; let mut signature = None ; let mut nonce = None ; let mut created_on = None ; let mut updated_on = None ; while let Some (key) = map . next_key () ? { match key { Field :: address => { if address . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: users :: include ! (@ field_serde_name ; address))) ; } address = Some (map . next_value () ?) ; } Field :: signature => { if signature . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: users :: include ! (@ field_serde_name ; signature))) ; } signature = Some (map . next_value () ?) ; } Field :: nonce => { if nonce . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: users :: include ! (@ field_serde_name ; nonce))) ; } nonce = Some (map . next_value () ?) ; } Field :: created_on => { if created_on . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: users :: include ! (@ field_serde_name ; created_on))) ; } created_on = Some (map . next_value () ?) ; } Field :: updated_on => { if updated_on . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: users :: include ! (@ field_serde_name ; updated_on))) ; } updated_on = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: users :: include ! (@ field_serde_name ; $ field))) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: users :: include ! (@ field_serde_name ; $ field))) ? ;) * let address = address . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: users :: include ! (@ field_serde_name ; address))) ? ; let signature = signature . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: users :: include ! (@ field_serde_name ; signature))) ? ; let nonce = nonce . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: users :: include ! (@ field_serde_name ; nonce))) ? ; let created_on = created_on . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: users :: include ! (@ field_serde_name ; created_on))) ? ; let updated_on = updated_on . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: users :: include ! (@ field_serde_name ; updated_on))) ? ; Ok (Data { address , signature , nonce , created_on , updated_on , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["address" , "signature" , "nonce" , "created_on" , "updated_on"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { $ crate :: prisma :: users :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Users" , available relations are "")) } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_include_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ ($ crate :: prisma :: users :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; address) => { "address" } ; (@ field_serde_name ; signature) => { "signature" } ; (@ field_serde_name ; nonce) => { "nonce" } ; (@ field_serde_name ; created_on) => { "created_on" } ; (@ field_serde_name ; updated_on) => { "updated_on" } ; }
    pub use _include_users as include;
    pub enum IncludeParam {
        Address(address::Include),
        Signature(signature::Include),
        Nonce(nonce::Include),
        CreatedOn(created_on::Include),
        UpdatedOn(updated_on::Include),
    }
    impl IncludeParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Address(data) => data.to_selection(),
                Self::Signature(data) => data.to_selection(),
                Self::Nonce(data) => data.to_selection(),
                Self::CreatedOn(data) => data.to_selection(),
                Self::UpdatedOn(data) => data.to_selection(),
            }
        }
    }
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub struct Data {
        #[serde(rename = "address")]
        pub address: String,
        #[serde(rename = "signature")]
        pub signature: String,
        #[serde(rename = "nonce")]
        pub nonce: String,
        #[serde(rename = "created_on")]
        pub created_on:
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        #[serde(rename = "updated_on")]
        pub updated_on: Option<
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        >,
    }
    impl Data {}
    #[derive(Clone)]
    pub enum WithParam {}
    impl Into<::prisma_client_rust::Selection> for WithParam {
        fn into(self) -> ::prisma_client_rust::Selection {
            match self {}
        }
    }
    #[derive(Clone)]
    pub enum SetParam {
        SetAddress(String),
        SetSignature(String),
        SetNonce(String),
        SetCreatedOn(
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        ),
        SetUpdatedOn(
            Option<
                ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
            >,
        ),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for SetParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self {
                SetParam::SetAddress(value) => (
                    "address".to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::SetSignature(value) => (
                    "signature".to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::SetNonce(value) => (
                    "nonce".to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::SetCreatedOn(value) => (
                    "created_on".to_string(),
                    ::prisma_client_rust::PrismaValue::DateTime(value),
                ),
                SetParam::SetUpdatedOn(value) => (
                    "updated_on".to_string(),
                    value
                        .map(|value| ::prisma_client_rust::PrismaValue::DateTime(value))
                        .unwrap_or(::prisma_client_rust::PrismaValue::Null),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum OrderByParam {
        Address(::prisma_client_rust::Direction),
        Signature(::prisma_client_rust::Direction),
        Nonce(::prisma_client_rust::Direction),
        CreatedOn(::prisma_client_rust::Direction),
        UpdatedOn(::prisma_client_rust::Direction),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self {
                Self::Address(direction) => (
                    "address".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Signature(direction) => (
                    "signature".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Nonce(direction) => (
                    "nonce".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::CreatedOn(direction) => (
                    "created_on".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::UpdatedOn(direction) => (
                    "updated_on".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        AddressEquals(String),
        AddressInVec(Vec<String>),
        AddressNotInVec(Vec<String>),
        AddressLt(String),
        AddressLte(String),
        AddressGt(String),
        AddressGte(String),
        AddressContains(String),
        AddressStartsWith(String),
        AddressEndsWith(String),
        AddressMode(QueryMode),
        AddressNot(String),
        SignatureEquals(String),
        SignatureInVec(Vec<String>),
        SignatureNotInVec(Vec<String>),
        SignatureLt(String),
        SignatureLte(String),
        SignatureGt(String),
        SignatureGte(String),
        SignatureContains(String),
        SignatureStartsWith(String),
        SignatureEndsWith(String),
        SignatureMode(QueryMode),
        SignatureNot(String),
        NonceEquals(String),
        NonceInVec(Vec<String>),
        NonceNotInVec(Vec<String>),
        NonceLt(String),
        NonceLte(String),
        NonceGt(String),
        NonceGte(String),
        NonceContains(String),
        NonceStartsWith(String),
        NonceEndsWith(String),
        NonceMode(QueryMode),
        NonceNot(String),
        CreatedOnEquals(
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        ),
        CreatedOnInVec(
            Vec<::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>>,
        ),
        CreatedOnNotInVec(
            Vec<::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>>,
        ),
        CreatedOnLt(
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        ),
        CreatedOnLte(
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        ),
        CreatedOnGt(
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        ),
        CreatedOnGte(
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        ),
        CreatedOnNot(
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        ),
        UpdatedOnEquals(
            Option<
                ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
            >,
        ),
        UpdatedOnInVec(
            Vec<::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>>,
        ),
        UpdatedOnNotInVec(
            Vec<::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>>,
        ),
        UpdatedOnLt(
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        ),
        UpdatedOnLte(
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        ),
        UpdatedOnGt(
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        ),
        UpdatedOnGte(
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        ),
        UpdatedOnNot(
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        ),
    }
    impl Into<::prisma_client_rust::SerializedWhere> for WhereParam {
        fn into(self) -> ::prisma_client_rust::SerializedWhere {
            match self {
                Self::Not(value) => ::prisma_client_rust::SerializedWhere::new(
                    "NOT",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        value
                            .into_iter()
                            .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                            .map(Into::into)
                            .collect(),
                    ),
                ),
                Self::Or(value) => ::prisma_client_rust::SerializedWhere::new(
                    "OR",
                    ::prisma_client_rust::SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                            .map(Into::into)
                            .map(|v| vec![v])
                            .map(::prisma_client_rust::PrismaValue::Object)
                            .collect(),
                    ),
                ),
                Self::And(value) => ::prisma_client_rust::SerializedWhere::new(
                    "AND",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        value
                            .into_iter()
                            .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                            .map(Into::into)
                            .collect(),
                    ),
                ),
                Self::AddressEquals(value) => ::prisma_client_rust::SerializedWhere::new(
                    "address",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::AddressInVec(value) => ::prisma_client_rust::SerializedWhere::new(
                    "address",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| ::prisma_client_rust::PrismaValue::String(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::AddressNotInVec(value) => ::prisma_client_rust::SerializedWhere::new(
                    "address",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| ::prisma_client_rust::PrismaValue::String(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::AddressLt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "address",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::AddressLte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "address",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::AddressGt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "address",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::AddressGte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "address",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::AddressContains(value) => ::prisma_client_rust::SerializedWhere::new(
                    "address",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "contains".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::AddressStartsWith(value) => ::prisma_client_rust::SerializedWhere::new(
                    "address",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "startsWith".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::AddressEndsWith(value) => ::prisma_client_rust::SerializedWhere::new(
                    "address",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "endsWith".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::AddressMode(value) => ::prisma_client_rust::SerializedWhere::new(
                    "address",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "mode".to_string(),
                        ::prisma_client_rust::PrismaValue::Enum(value.to_string()),
                    )]),
                ),
                Self::AddressNot(value) => ::prisma_client_rust::SerializedWhere::new(
                    "address",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::SignatureEquals(value) => ::prisma_client_rust::SerializedWhere::new(
                    "signature",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::SignatureInVec(value) => ::prisma_client_rust::SerializedWhere::new(
                    "signature",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| ::prisma_client_rust::PrismaValue::String(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::SignatureNotInVec(value) => ::prisma_client_rust::SerializedWhere::new(
                    "signature",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| ::prisma_client_rust::PrismaValue::String(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::SignatureLt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "signature",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::SignatureLte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "signature",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::SignatureGt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "signature",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::SignatureGte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "signature",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::SignatureContains(value) => ::prisma_client_rust::SerializedWhere::new(
                    "signature",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "contains".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::SignatureStartsWith(value) => ::prisma_client_rust::SerializedWhere::new(
                    "signature",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "startsWith".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::SignatureEndsWith(value) => ::prisma_client_rust::SerializedWhere::new(
                    "signature",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "endsWith".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::SignatureMode(value) => ::prisma_client_rust::SerializedWhere::new(
                    "signature",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "mode".to_string(),
                        ::prisma_client_rust::PrismaValue::Enum(value.to_string()),
                    )]),
                ),
                Self::SignatureNot(value) => ::prisma_client_rust::SerializedWhere::new(
                    "signature",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::NonceEquals(value) => ::prisma_client_rust::SerializedWhere::new(
                    "nonce",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::NonceInVec(value) => ::prisma_client_rust::SerializedWhere::new(
                    "nonce",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| ::prisma_client_rust::PrismaValue::String(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::NonceNotInVec(value) => ::prisma_client_rust::SerializedWhere::new(
                    "nonce",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| ::prisma_client_rust::PrismaValue::String(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::NonceLt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "nonce",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::NonceLte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "nonce",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::NonceGt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "nonce",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::NonceGte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "nonce",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::NonceContains(value) => ::prisma_client_rust::SerializedWhere::new(
                    "nonce",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "contains".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::NonceStartsWith(value) => ::prisma_client_rust::SerializedWhere::new(
                    "nonce",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "startsWith".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::NonceEndsWith(value) => ::prisma_client_rust::SerializedWhere::new(
                    "nonce",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "endsWith".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::NonceMode(value) => ::prisma_client_rust::SerializedWhere::new(
                    "nonce",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "mode".to_string(),
                        ::prisma_client_rust::PrismaValue::Enum(value.to_string()),
                    )]),
                ),
                Self::NonceNot(value) => ::prisma_client_rust::SerializedWhere::new(
                    "nonce",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::CreatedOnEquals(value) => ::prisma_client_rust::SerializedWhere::new(
                    "created_on",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        ::prisma_client_rust::PrismaValue::DateTime(value),
                    )]),
                ),
                Self::CreatedOnInVec(value) => ::prisma_client_rust::SerializedWhere::new(
                    "created_on",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| ::prisma_client_rust::PrismaValue::DateTime(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::CreatedOnNotInVec(value) => ::prisma_client_rust::SerializedWhere::new(
                    "created_on",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| ::prisma_client_rust::PrismaValue::DateTime(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::CreatedOnLt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "created_on",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        ::prisma_client_rust::PrismaValue::DateTime(value),
                    )]),
                ),
                Self::CreatedOnLte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "created_on",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        ::prisma_client_rust::PrismaValue::DateTime(value),
                    )]),
                ),
                Self::CreatedOnGt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "created_on",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        ::prisma_client_rust::PrismaValue::DateTime(value),
                    )]),
                ),
                Self::CreatedOnGte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "created_on",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        ::prisma_client_rust::PrismaValue::DateTime(value),
                    )]),
                ),
                Self::CreatedOnNot(value) => ::prisma_client_rust::SerializedWhere::new(
                    "created_on",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        ::prisma_client_rust::PrismaValue::DateTime(value),
                    )]),
                ),
                Self::UpdatedOnEquals(value) => ::prisma_client_rust::SerializedWhere::new(
                    "updated_on",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        value
                            .map(|value| ::prisma_client_rust::PrismaValue::DateTime(value))
                            .unwrap_or(::prisma_client_rust::PrismaValue::Null),
                    )]),
                ),
                Self::UpdatedOnInVec(value) => ::prisma_client_rust::SerializedWhere::new(
                    "updated_on",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| ::prisma_client_rust::PrismaValue::DateTime(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::UpdatedOnNotInVec(value) => ::prisma_client_rust::SerializedWhere::new(
                    "updated_on",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| ::prisma_client_rust::PrismaValue::DateTime(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::UpdatedOnLt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "updated_on",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        ::prisma_client_rust::PrismaValue::DateTime(value),
                    )]),
                ),
                Self::UpdatedOnLte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "updated_on",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        ::prisma_client_rust::PrismaValue::DateTime(value),
                    )]),
                ),
                Self::UpdatedOnGt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "updated_on",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        ::prisma_client_rust::PrismaValue::DateTime(value),
                    )]),
                ),
                Self::UpdatedOnGte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "updated_on",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        ::prisma_client_rust::PrismaValue::DateTime(value),
                    )]),
                ),
                Self::UpdatedOnNot(value) => ::prisma_client_rust::SerializedWhere::new(
                    "updated_on",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        ::prisma_client_rust::PrismaValue::DateTime(value),
                    )]),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum UniqueWhereParam {
        AddressEquals(String),
    }
    impl From<UniqueWhereParam> for WhereParam {
        fn from(value: UniqueWhereParam) -> Self {
            match value {
                UniqueWhereParam::AddressEquals(value) => Self::AddressEquals(value),
            }
        }
    }
    impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
        fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
            match op {
                ::prisma_client_rust::Operator::Not(value) => Self::Not(value),
                ::prisma_client_rust::Operator::And(value) => Self::And(value),
                ::prisma_client_rust::Operator::Or(value) => Self::Or(value),
            }
        }
    }
    pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<WithParam>;
    pub type ManyArgs =
        ::prisma_client_rust::ManyArgs<WhereParam, WithParam, OrderByParam, UniqueWhereParam>;
    pub type Count<'a> =
        ::prisma_client_rust::Count<'a, WhereParam, OrderByParam, UniqueWhereParam>;
    pub type Create<'a> = ::prisma_client_rust::Create<'a, SetParam, WithParam, Data>;
    pub type CreateMany<'a> = ::prisma_client_rust::CreateMany<'a, SetParam>;
    pub type FindUnique<'a> =
        ::prisma_client_rust::FindUnique<'a, WhereParam, WithParam, SetParam, Data>;
    pub type FindMany<'a> = ::prisma_client_rust::FindMany<
        'a,
        WhereParam,
        WithParam,
        OrderByParam,
        UniqueWhereParam,
        SetParam,
        Data,
    >;
    pub type FindFirst<'a> = ::prisma_client_rust::FindFirst<
        'a,
        WhereParam,
        WithParam,
        OrderByParam,
        UniqueWhereParam,
        Data,
    >;
    pub type Update<'a> = ::prisma_client_rust::Update<'a, WhereParam, WithParam, SetParam, Data>;
    pub type UpdateMany<'a> = ::prisma_client_rust::UpdateMany<'a, WhereParam, SetParam>;
    pub type Upsert<'a> = ::prisma_client_rust::Upsert<'a, WhereParam, SetParam, WithParam, Data>;
    pub type Delete<'a> = ::prisma_client_rust::Delete<'a, WhereParam, WithParam, Data>;
    pub type DeleteMany<'a> = ::prisma_client_rust::DeleteMany<'a, WhereParam>;
    pub struct Actions<'a> {
        pub client: &'a PrismaClient,
    }
    impl<'a> Actions<'a> {
        pub fn find_unique(self, _where: UniqueWhereParam) -> FindUnique<'a> {
            FindUnique::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("users", _outputs()),
                _where.into(),
            )
        }
        pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirst<'a> {
            FindFirst::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("users", _outputs()),
                _where,
            )
        }
        pub fn find_many(self, _where: Vec<WhereParam>) -> FindMany<'a> {
            FindMany::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("users", _outputs()),
                _where,
            )
        }
        pub fn create(
            self,
            address: String,
            signature: String,
            nonce: String,
            created_on: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
            mut _params: Vec<SetParam>,
        ) -> Create<'a> {
            _params.push(address::set(address));
            _params.push(signature::set(signature));
            _params.push(nonce::set(nonce));
            _params.push(created_on::set(created_on));
            Create::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("users", _outputs()),
                _params,
            )
        }
        pub fn create_many(
            self,
            data: Vec<(
                String,
                String,
                String,
                ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
                Vec<SetParam>,
            )>,
        ) -> CreateMany<'a> {
            let data = data
                .into_iter()
                .map(|(address, signature, nonce, created_on, mut _params)| {
                    _params.push(address::set(address));
                    _params.push(signature::set(signature));
                    _params.push(nonce::set(nonce));
                    _params.push(created_on::set(created_on));
                    _params
                })
                .collect();
            CreateMany::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("users", _outputs()),
                data,
            )
        }
        pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> Update<'a> {
            Update::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("users", _outputs()),
                _where.into(),
                _params,
                vec![],
            )
        }
        pub fn update_many(
            self,
            _where: Vec<WhereParam>,
            _params: Vec<SetParam>,
        ) -> UpdateMany<'a> {
            UpdateMany::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("users", _outputs()),
                _where,
                _params,
            )
        }
        pub fn upsert(
            self,
            _where: UniqueWhereParam,
            (address, signature, nonce, created_on, mut _params): (
                String,
                String,
                String,
                ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
                Vec<SetParam>,
            ),
            _update: Vec<SetParam>,
        ) -> Upsert<'a> {
            _params.push(address::set(address));
            _params.push(signature::set(signature));
            _params.push(nonce::set(nonce));
            _params.push(created_on::set(created_on));
            Upsert::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("users", _outputs()),
                _where.into(),
                _params,
                _update,
            )
        }
        pub fn delete(self, _where: UniqueWhereParam) -> Delete<'a> {
            Delete::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("users", _outputs()),
                _where.into(),
                vec![],
            )
        }
        pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteMany<'a> {
            DeleteMany::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("users", _outputs()),
                _where.into(),
            )
        }
        pub fn count(self, _where: Vec<WhereParam>) -> Count<'a> {
            Count::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("users", _outputs()),
                vec![],
            )
        }
    }
}
pub mod _prisma {
    pub struct PrismaClient {
        executor: ::prisma_client_rust::Executor,
        query_schema: ::std::sync::Arc<::prisma_client_rust::schema::QuerySchema>,
    }
    impl ::std::fmt::Debug for PrismaClient {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.debug_struct("PrismaClient").finish()
        }
    }
    impl PrismaClient {
        pub(super) fn _new_query_context(&self) -> ::prisma_client_rust::queries::QueryContext {
            ::prisma_client_rust::queries::QueryContext::new(&self.executor, &self.query_schema)
        }
        pub(super) fn _new(
            executor: ::prisma_client_rust::Executor,
            query_schema: std::sync::Arc<::prisma_client_rust::schema::QuerySchema>,
        ) -> Self {
            Self {
                executor,
                query_schema,
            }
        }
        pub fn _query_raw<T: serde::de::DeserializeOwned>(
            &self,
            query: ::prisma_client_rust::raw::Raw,
        ) -> ::prisma_client_rust::QueryRaw<T> {
            ::prisma_client_rust::QueryRaw::new(
                ::prisma_client_rust::queries::QueryContext::new(
                    &self.executor,
                    &self.query_schema,
                ),
                query,
                super::DATABASE_STR,
            )
        }
        pub fn _execute_raw(
            &self,
            query: ::prisma_client_rust::raw::Raw,
        ) -> ::prisma_client_rust::ExecuteRaw {
            ::prisma_client_rust::ExecuteRaw::new(
                ::prisma_client_rust::queries::QueryContext::new(
                    &self.executor,
                    &self.query_schema,
                ),
                query,
                super::DATABASE_STR,
            )
        }
        pub async fn _batch<T: ::prisma_client_rust::BatchContainer<Marker>, Marker>(
            &self,
            queries: T,
        ) -> ::prisma_client_rust::queries::Result<T::ReturnType> {
            ::prisma_client_rust::batch(queries, &self.executor, &self.query_schema).await
        }
        pub fn stores(&self) -> super::stores::Actions {
            super::stores::Actions { client: &self }
        }
        pub fn users(&self) -> super::users::Actions {
            super::users::Actions { client: &self }
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum QueryMode {
        #[serde(rename = "default")]
        Default,
        #[serde(rename = "insensitive")]
        Insensitive,
    }
    impl ToString for QueryMode {
        fn to_string(&self) -> String {
            match self {
                Self::Default => "default".to_string(),
                Self::Insensitive => "insensitive".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum SortOrder {
        #[serde(rename = "asc")]
        Asc,
        #[serde(rename = "desc")]
        Desc,
    }
    impl ToString for SortOrder {
        fn to_string(&self) -> String {
            match self {
                Self::Asc => "asc".to_string(),
                Self::Desc => "desc".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum StoresScalarFieldEnum {
        #[serde(rename = "store_id")]
        StoreId,
        #[serde(rename = "creator")]
        Creator,
        #[serde(rename = "store_name")]
        StoreName,
        #[serde(rename = "store_description")]
        StoreDescription,
        #[serde(rename = "store_tier")]
        StoreTier,
        #[serde(rename = "store_ip")]
        StoreIp,
        #[serde(rename = "store_domain")]
        StoreDomain,
        #[serde(rename = "created_on")]
        CreatedOn,
        #[serde(rename = "updated_on")]
        UpdatedOn,
    }
    impl ToString for StoresScalarFieldEnum {
        fn to_string(&self) -> String {
            match self {
                Self::StoreId => "store_id".to_string(),
                Self::Creator => "creator".to_string(),
                Self::StoreName => "store_name".to_string(),
                Self::StoreDescription => "store_description".to_string(),
                Self::StoreTier => "store_tier".to_string(),
                Self::StoreIp => "store_ip".to_string(),
                Self::StoreDomain => "store_domain".to_string(),
                Self::CreatedOn => "created_on".to_string(),
                Self::UpdatedOn => "updated_on".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum TransactionIsolationLevel {
        #[serde(rename = "ReadUncommitted")]
        ReadUncommitted,
        #[serde(rename = "ReadCommitted")]
        ReadCommitted,
        #[serde(rename = "RepeatableRead")]
        RepeatableRead,
        #[serde(rename = "Serializable")]
        Serializable,
    }
    impl ToString for TransactionIsolationLevel {
        fn to_string(&self) -> String {
            match self {
                Self::ReadUncommitted => "ReadUncommitted".to_string(),
                Self::ReadCommitted => "ReadCommitted".to_string(),
                Self::RepeatableRead => "RepeatableRead".to_string(),
                Self::Serializable => "Serializable".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum UsersScalarFieldEnum {
        #[serde(rename = "address")]
        Address,
        #[serde(rename = "signature")]
        Signature,
        #[serde(rename = "nonce")]
        Nonce,
        #[serde(rename = "created_on")]
        CreatedOn,
        #[serde(rename = "updated_on")]
        UpdatedOn,
    }
    impl ToString for UsersScalarFieldEnum {
        fn to_string(&self) -> String {
            match self {
                Self::Address => "address".to_string(),
                Self::Signature => "signature".to_string(),
                Self::Nonce => "nonce".to_string(),
                Self::CreatedOn => "created_on".to_string(),
                Self::UpdatedOn => "updated_on".to_string(),
            }
        }
    }
}
pub use _prisma::PrismaClient;
